/**
 * OAuth Configuration
 * Centralized OAuth provider configuration and strategies
 */

import passport from 'passport';
import { Strategy as GoogleStrategy } from 'passport-google-oauth20';
import { Strategy as GitHubStrategy } from 'passport-github2';
import { Strategy as LinkedInStrategy } from 'passport-linkedin-oauth2';
import { Strategy as JwtStrategy, ExtractJwt } from 'passport-jwt';
import { prisma } from './database';
import { logger } from '../utils/logger';
import { AuthProvider, UserRole } from '@prisma/client';

export interface OAuthProfile {
  provider: AuthProvider;
  providerId: string;
  email: string;
  emailVerified?: boolean;
  firstName?: string;
  lastName?: string;
  displayName?: string;
  avatar?: string;
  accessToken?: string;
  refreshToken?: string;
  tokenExpiry?: Date;
  raw?: any;
}

export interface OAuthConfig {
  clientId: string;
  clientSecret: string;
  callbackURL: string;
  scope?: string[];
  authorizationURL?: string;
  tokenURL?: string;
  userProfileURL?: string;
}

export class OAuthService {
  private configs: Map<AuthProvider, OAuthConfig> = new Map();

  constructor() {
    this.loadConfigurations();
    this.initializeStrategies();
  }

  /**
   * Load OAuth configurations from environment
   */
  private loadConfigurations(): void {
    // Google OAuth Configuration
    if (process.env.GOOGLE_CLIENT_ID && process.env.GOOGLE_CLIENT_SECRET) {
      this.configs.set(AuthProvider.GOOGLE, {
        clientId: process.env.GOOGLE_CLIENT_ID,
        clientSecret: process.env.GOOGLE_CLIENT_SECRET,
        callbackURL: `${process.env.BACKEND_URL || 'http://localhost:5000'}/api/auth/google/callback`,
        scope: [
          'profile',
          'email',
          'openid',
          'https://www.googleapis.com/auth/calendar',
          'https://www.googleapis.com/auth/calendar.events',
          'https://www.googleapis.com/auth/calendar.readonly',
          'https://www.googleapis.com/auth/calendar.events.readonly',
          'https://www.googleapis.com/auth/calendar.calendarlist.readonly'
        ],
      });
    }

    // GitHub OAuth Configuration
    if (process.env.GITHUB_CLIENT_ID && process.env.GITHUB_CLIENT_SECRET) {
      this.configs.set(AuthProvider.GITHUB, {
        clientId: process.env.GITHUB_CLIENT_ID,
        clientSecret: process.env.GITHUB_CLIENT_SECRET,
        callbackURL: `${process.env.BACKEND_URL || 'http://localhost:5000'}/api/auth/github/callback`,
        scope: [
          'user:email', 
          'read:user', 
          'public_repo', 
          'read:org',
          'user:follow'
        ],
      });
    }

    // LinkedIn OAuth Configuration
    if (process.env.LINKEDIN_CLIENT_ID && process.env.LINKEDIN_CLIENT_SECRET) {
      this.configs.set(AuthProvider.LINKEDIN, {
        clientId: process.env.LINKEDIN_CLIENT_ID,
        clientSecret: process.env.LINKEDIN_CLIENT_SECRET,
        callbackURL: `${process.env.BACKEND_URL || 'http://localhost:5000'}/api/auth/linkedin/callback`,
        scope: [
          'r_emailaddress',
          'r_liteprofile',
          'r_basicprofile',
          'w_member_social',
          'r_organization_social',
          'rw_organization_admin'
        ],
        authorizationURL: 'https://www.linkedin.com/oauth/v2/authorization',
        tokenURL: 'https://www.linkedin.com/oauth/v2/accessToken',
        userProfileURL: 'https://api.linkedin.com/v2/me',
      });
    }
  }

  /**
   * Initialize Passport strategies
   */
  private initializeStrategies(): void {
    // JWT Strategy
    passport.use(
      new JwtStrategy(
        {
          jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
          secretOrKey: process.env.JWT_SECRET!,
        },
        async (payload, done) => {
          try {
            const user = await prisma.user.findUnique({
              where: { id: payload.userId },
              select: {
                id: true,
                email: true,
                role: true,
                isActive: true,
                isEmailVerified: true,
              },
            });

            if (user && user.isActive) {
              return done(null, user);
            }
            return done(null, false);
          } catch (error) {
            return done(error, false);
          }
        }
      )
    );

    // Google Strategy
    const googleConfig = this.configs.get(AuthProvider.GOOGLE);
    if (googleConfig) {
      passport.use(
        new GoogleStrategy(
          {
            clientID: googleConfig.clientId,
            clientSecret: googleConfig.clientSecret,
            callbackURL: googleConfig.callbackURL,
            scope: googleConfig.scope,
          },
          async (accessToken, refreshToken, profile, done) => {
            try {
              const oauthProfile = this.parseGoogleProfile(profile, accessToken, refreshToken);
              return done(null, oauthProfile);
            } catch (error) {
              return done(error as Error, null);
            }
          }
        )
      );
    }

    // GitHub Strategy
    const githubConfig = this.configs.get(AuthProvider.GITHUB);
    if (githubConfig) {
      passport.use(
        new GitHubStrategy(
          {
            clientID: githubConfig.clientId,
            clientSecret: githubConfig.clientSecret,
            callbackURL: githubConfig.callbackURL,
            scope: githubConfig.scope,
          },
          async (accessToken: string, refreshToken: string, profile: any, done: any) => {
            try {
              const oauthProfile = this.parseGitHubProfile(profile, accessToken, refreshToken);
              return done(null, oauthProfile);
            } catch (error) {
              return done(error, null);
            }
          }
        )
      );
    }

    // LinkedIn Strategy
    const linkedinConfig = this.configs.get(AuthProvider.LINKEDIN);
    if (linkedinConfig) {
      passport.use(
        new LinkedInStrategy(
          {
            clientID: linkedinConfig.clientId,
            clientSecret: linkedinConfig.clientSecret,
            callbackURL: linkedinConfig.callbackURL,
            scope: linkedinConfig.scope,
            state: true,
          },
          async (accessToken: string, refreshToken: string, profile: any, done: any) => {
            try {
              const oauthProfile = this.parseLinkedInProfile(profile, accessToken, refreshToken);
              return done(null, oauthProfile);
            } catch (error) {
              logger.error('LinkedIn OAuth strategy error', { error, profileId: profile?.id });
              return done(error, null);
            }
          }
        )
      );
    }

    // Serialize/Deserialize user
    passport.serializeUser((user: any, done) => {
      done(null, user.id || user.providerId);
    });

    passport.deserializeUser(async (id: string, done) => {
      try {
        const user = await prisma.user.findUnique({
          where: { id },
          select: {
            id: true,
            email: true,
            role: true,
            firstName: true,
            lastName: true,
          },
        });
        done(null, user);
      } catch (error) {
        done(error, null);
      }
    });
  }

  /**
   * Parse Google OAuth profile
   */
  private parseGoogleProfile(profile: any, accessToken: string, refreshToken?: string): OAuthProfile {
    const email = profile.emails?.[0]?.value;
    const emailVerified = profile.emails?.[0]?.verified;
    const photo = profile.photos?.[0]?.value;

    return {
      provider: AuthProvider.GOOGLE,
      providerId: profile.id,
      email: email!,
      emailVerified,
      firstName: profile.name?.givenName,
      lastName: profile.name?.familyName,
      displayName: profile.displayName,
      avatar: photo,
      accessToken,
      refreshToken,
      tokenExpiry: this.calculateTokenExpiry(),
      raw: profile._json,
    };
  }

  /**
   * Parse GitHub OAuth profile with enhanced data
   */
  private parseGitHubProfile(profile: any, accessToken: string, refreshToken?: string): OAuthProfile {
    const email = profile.emails?.[0]?.value || profile._json?.email;
    const nameParts = profile._json?.name?.split(' ') || [];
    
    return {
      provider: AuthProvider.GITHUB,
      providerId: profile.id,
      email: email!,
      emailVerified: true, // GitHub emails are verified
      firstName: nameParts[0] || profile.username,
      lastName: nameParts.slice(1).join(' ') || '',
      displayName: profile.displayName || profile._json?.name || profile.username,
      avatar: profile._json?.avatar_url,
      accessToken,
      refreshToken,
      tokenExpiry: this.calculateTokenExpiry(),
      raw: {
        ...profile._json,
        portfolioData: {
          username: profile.username || profile._json?.login,
          profileUrl: profile._json?.html_url,
          publicRepos: profile._json?.public_repos || 0,
          followers: profile._json?.followers || 0,
          following: profile._json?.following || 0,
          bio: profile._json?.bio,
          company: profile._json?.company,
          location: profile._json?.location,
          blog: profile._json?.blog,
          hireable: profile._json?.hireable,
          createdAt: profile._json?.created_at,
          updatedAt: profile._json?.updated_at
        }
      },
    };
  }

  /**
   * Get enhanced GitHub portfolio data
   */
  async getGitHubPortfolioData(accessToken: string, username: string): Promise<any> {
    try {
      const [userProfile, repositories, organizations] = await Promise.all([
        fetch(`https://api.github.com/user`, {
          headers: {
            'Authorization': `Bearer ${accessToken}`,
            'Accept': 'application/vnd.github.v3+json',
            'User-Agent': 'CastMatch-Platform'
          }
        }),
        fetch(`https://api.github.com/user/repos?sort=updated&per_page=10`, {
          headers: {
            'Authorization': `Bearer ${accessToken}`,
            'Accept': 'application/vnd.github.v3+json',
            'User-Agent': 'CastMatch-Platform'
          }
        }),
        fetch(`https://api.github.com/user/orgs`, {
          headers: {
            'Authorization': `Bearer ${accessToken}`,
            'Accept': 'application/vnd.github.v3+json',
            'User-Agent': 'CastMatch-Platform'
          }
        }).catch(() => ({ json: () => Promise.resolve([]) })) // Graceful fallback
      ]);

      const [user, repos, orgs] = await Promise.all([
        userProfile.json(),
        repositories.json(),
        organizations.json()
      ]);

      // Get featured repositories (pinned or most starred)
      const featuredRepos = repos
        .filter((repo: any) => !repo.fork && repo.stargazers_count > 0)
        .sort((a: any, b: any) => b.stargazers_count - a.stargazers_count)
        .slice(0, 6)
        .map((repo: any) => ({
          name: repo.name,
          description: repo.description,
          url: repo.html_url,
          stars: repo.stargazers_count,
          forks: repo.forks_count,
          language: repo.language,
          topics: repo.topics || [],
          updatedAt: repo.updated_at
        }));

      return {
        profile: user,
        repositories: repos,
        organizations: orgs,
        featuredRepositories: featuredRepos,
        stats: {
          totalRepos: user.public_repos,
          totalStars: repos.reduce((sum: number, repo: any) => sum + repo.stargazers_count, 0),
          totalForks: repos.reduce((sum: number, repo: any) => sum + repo.forks_count, 0),
          languages: this.extractLanguageStats(repos),
          organizationCount: orgs.length
        },
        lastSynced: new Date().toISOString()
      };
    } catch (error) {
      logger.error('Failed to fetch GitHub portfolio data', error);
      throw error;
    }
  }

  /**
   * Extract language statistics from repositories
   */
  private extractLanguageStats(repos: any[]): Record<string, number> {
    const languageCount: Record<string, number> = {};
    
    repos.forEach(repo => {
      if (repo.language) {
        languageCount[repo.language] = (languageCount[repo.language] || 0) + 1;
      }
    });
    
    return Object.fromEntries(
      Object.entries(languageCount)
        .sort(([,a], [,b]) => b - a)
        .slice(0, 10) // Top 10 languages
    );
  }

  /**
   * Get Google Calendar integration data
   */
  async getGoogleCalendarData(accessToken: string): Promise<any> {
    try {
      const [calendars, settings] = await Promise.all([
        fetch('https://www.googleapis.com/calendar/v3/users/me/calendarList', {
          headers: {
            'Authorization': `Bearer ${accessToken}`,
            'Accept': 'application/json'
          }
        }),
        fetch('https://www.googleapis.com/calendar/v3/users/me/settings', {
          headers: {
            'Authorization': `Bearer ${accessToken}`,
            'Accept': 'application/json'
          }
        }).catch(() => ({ json: () => Promise.resolve({ items: [] }) }))
      ]);

      const [calendarList, userSettings] = await Promise.all([
        calendars.json(),
        settings.json()
      ]);

      // Filter writable calendars for audition scheduling
      const writableCalendars = calendarList.items?.filter((cal: any) => 
        cal.accessRole === 'owner' || cal.accessRole === 'writer'
      ) || [];

      // Get timezone from settings
      const timezone = userSettings.items?.find((item: any) => item.id === 'timezone')?.value || 'UTC';

      return {
        calendars: calendarList.items || [],
        writableCalendars,
        primaryCalendar: calendarList.items?.find((cal: any) => cal.primary),
        timezone,
        integrationCapabilities: {
          canCreateEvents: writableCalendars.length > 0,
          canReadEvents: true,
          canManageCalendars: writableCalendars.some((cal: any) => cal.accessRole === 'owner'),
          availableCalendars: writableCalendars.length
        },
        lastSynced: new Date().toISOString()
      };
    } catch (error) {
      logger.error('Failed to fetch Google Calendar data', error);
      throw error;
    }
  }

  /**
   * Create audition event in Google Calendar
   */
  async createGoogleCalendarEvent(accessToken: string, eventData: {
    calendarId?: string;
    title: string;
    description?: string;
    startTime: string;
    endTime: string;
    timezone?: string;
    attendees?: string[];
    location?: string;
  }): Promise<any> {
    try {
      const calendarId = eventData.calendarId || 'primary';
      
      const event = {
        summary: eventData.title,
        description: eventData.description || '',
        location: eventData.location || '',
        start: {
          dateTime: eventData.startTime,
          timeZone: eventData.timezone || 'UTC'
        },
        end: {
          dateTime: eventData.endTime,
          timeZone: eventData.timezone || 'UTC'
        },
        attendees: eventData.attendees?.map(email => ({ email })) || [],
        reminders: {
          useDefault: false,
          overrides: [
            { method: 'email', minutes: 24 * 60 }, // 1 day before
            { method: 'popup', minutes: 30 }, // 30 minutes before
          ]
        },
        source: {
          title: 'CastMatch Audition',
          url: process.env.FRONTEND_URL || 'https://castmatch.com'
        }
      };

      const response = await fetch(
        `https://www.googleapis.com/calendar/v3/calendars/${encodeURIComponent(calendarId)}/events`,
        {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${accessToken}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(event)
        }
      );

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(`Google Calendar API error: ${errorData.error?.message || response.statusText}`);
      }

      return response.json();
    } catch (error) {
      logger.error('Failed to create Google Calendar event', error);
      throw error;
    }
  }

  /**
   * Check calendar availability for audition scheduling
   */
  async checkGoogleCalendarAvailability(accessToken: string, params: {
    calendarIds: string[];
    timeMin: string;
    timeMax: string;
    timezone?: string;
  }): Promise<any> {
    try {
      const freeBusyRequest = {
        timeMin: params.timeMin,
        timeMax: params.timeMax,
        timeZone: params.timezone || 'UTC',
        items: params.calendarIds.map(id => ({ id }))
      };

      const response = await fetch(
        'https://www.googleapis.com/calendar/v3/freeBusy',
        {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${accessToken}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(freeBusyRequest)
        }
      );

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(`Google Calendar FreeBusy API error: ${errorData.error?.message || response.statusText}`);
      }

      const data = await response.json();
      
      // Process free/busy data to find available slots
      const availability = Object.entries(data.calendars).map(([calendarId, calendarData]: [string, any]) => ({
        calendarId,
        busy: calendarData.busy || [],
        errors: calendarData.errors || []
      }));

      return {
        timeMin: params.timeMin,
        timeMax: params.timeMax,
        calendars: availability,
        hasConflicts: availability.some(cal => cal.busy.length > 0),
        checkedAt: new Date().toISOString()
      };
    } catch (error) {
      logger.error('Failed to check Google Calendar availability', error);
      throw error;
    }
  }

  /**
   * Parse LinkedIn OAuth profile
   */
  private parseLinkedInProfile(profile: any, accessToken: string, refreshToken?: string): OAuthProfile {
    const email = profile.emails?.[0]?.value || profile._json?.emailAddress;
    const firstName = profile._json?.localizedFirstName || profile.name?.givenName;
    const lastName = profile._json?.localizedLastName || profile.name?.familyName;
    
    return {
      provider: AuthProvider.LINKEDIN,
      providerId: profile.id,
      email: email!,
      emailVerified: true, // LinkedIn emails are verified
      firstName,
      lastName,
      displayName: profile.displayName || `${firstName} ${lastName}`.trim(),
      avatar: profile._json?.profilePicture?.['displayImage~']?.elements?.[0]?.identifiers?.[0]?.identifier || profile.photos?.[0]?.value,
      accessToken,
      refreshToken,
      tokenExpiry: this.calculateTokenExpiry(),
      raw: profile._json,
    };
  }

  /**
   * Calculate token expiry (default 60 days)
   */
  private calculateTokenExpiry(): Date {
    return new Date(Date.now() + 60 * 24 * 60 * 60 * 1000); // 60 days
  }

  /**
   * Handle OAuth callback and create/update user
   */
  async handleOAuthCallback(profile: OAuthProfile, defaultRole: UserRole = UserRole.ACTOR): Promise<any> {
    try {
      // Check if social account exists
      let socialAccount = await prisma.socialAccount.findUnique({
        where: {
          provider_providerUserId: {
            provider: profile.provider,
            providerUserId: profile.providerId,
          },
        },
        include: {
          user: true,
        },
      });

      let user;

      if (socialAccount) {
        // Update existing social account
        await prisma.socialAccount.update({
          where: { id: socialAccount.id },
          data: {
            accessToken: profile.accessToken,
            refreshToken: profile.refreshToken,
            tokenExpiry: profile.tokenExpiry,
            lastUsed: new Date(),
            profile: profile.raw,
          },
        });

        user = socialAccount.user;

        // Update user info if needed
        if (!user.avatar && profile.avatar) {
          await prisma.user.update({
            where: { id: user.id },
            data: { avatar: profile.avatar },
          });
        }
      } else {
        // Check if user with email exists
        user = await prisma.user.findUnique({
          where: { email: profile.email },
        });

        if (user) {
          // Link social account to existing user
          socialAccount = await prisma.socialAccount.create({
            data: {
              userId: user.id,
              provider: profile.provider,
              providerUserId: profile.providerId,
              email: profile.email,
              displayName: profile.displayName,
              avatar: profile.avatar,
              accessToken: profile.accessToken,
              refreshToken: profile.refreshToken,
              tokenExpiry: profile.tokenExpiry,
              isLinked: true,
              lastUsed: new Date(),
              profile: profile.raw,
            },
          });
        } else {
          // Create new user with social account
          const result = await prisma.$transaction(async (tx) => {
            const newUser = await tx.user.create({
              data: {
                email: profile.email,
                firstName: profile.firstName,
                lastName: profile.lastName,
                avatar: profile.avatar,
                role: defaultRole,
                isEmailVerified: profile.emailVerified || false,
                isActive: true,
                lastLogin: new Date(),
                password: '', // No password for OAuth users
              },
            });

            const newSocialAccount = await tx.socialAccount.create({
              data: {
                userId: newUser.id,
                provider: profile.provider,
                providerUserId: profile.providerId,
                email: profile.email,
                displayName: profile.displayName,
                avatar: profile.avatar,
                accessToken: profile.accessToken,
                refreshToken: profile.refreshToken,
                tokenExpiry: profile.tokenExpiry,
                isLinked: true,
                lastUsed: new Date(),
                profile: profile.raw,
              },
            });

            return { user: newUser, socialAccount: newSocialAccount };
          });

          user = result.user;
          socialAccount = result.socialAccount;
        }
      }

      // Log successful OAuth
      logger.info('OAuth authentication successful', {
        userId: user.id,
        provider: profile.provider,
        email: profile.email,
      });

      return {
        user,
        socialAccount,
        isNewUser: !socialAccount.user,
      };
    } catch (error) {
      logger.error('OAuth callback error', { error, profile });
      throw error;
    }
  }

  /**
   * Revoke OAuth tokens
   */
  async revokeOAuthTokens(userId: string, provider: AuthProvider): Promise<void> {
    try {
      const socialAccount = await prisma.socialAccount.findFirst({
        where: {
          userId,
          provider,
        },
      });

      if (!socialAccount) {
        throw new Error('Social account not found');
      }

      // Provider-specific revocation with retry logic
      const maxRetries = 3;
      let lastError;
      
      for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
          switch (provider) {
            case AuthProvider.GOOGLE:
              await this.revokeGoogleTokens(socialAccount.accessToken!);
              break;
            
            case AuthProvider.GITHUB:
              await this.revokeGitHubTokens(socialAccount.accessToken!);
              break;
              
            case AuthProvider.LINKEDIN:
              await this.revokeLinkedInTokens(socialAccount.accessToken!);
              break;
          }
          break; // Success, exit retry loop
        } catch (error) {
          lastError = error;
          logger.warn(`Token revocation attempt ${attempt} failed for ${provider}`, { error, userId });
          
          if (attempt < maxRetries) {
            await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000)); // Exponential backoff
          }
        }
      }
      
      if (lastError) {
        logger.error(`All token revocation attempts failed for ${provider}`, { error: lastError, userId });
      }

      // Update social account
      await prisma.socialAccount.update({
        where: { id: socialAccount.id },
        data: {
          isLinked: false,
          accessToken: null,
          refreshToken: null,
          tokenExpiry: null,
        },
      });

      logger.info('OAuth tokens revoked', { userId, provider });
    } catch (error) {
      logger.error('Failed to revoke OAuth tokens', { error, userId, provider });
      throw error;
    }
  }

  /**
   * Revoke Google OAuth tokens
   */
  private async revokeGoogleTokens(accessToken: string): Promise<void> {
    try {
      const response = await fetch(`https://oauth2.googleapis.com/revoke?token=${accessToken}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
        },
      });

      if (!response.ok) {
        throw new Error(`Google revocation failed: ${response.statusText}`);
      }
    } catch (error) {
      logger.error('Failed to revoke Google tokens', error);
      throw error;
    }
  }

  /**
   * Revoke GitHub OAuth tokens
   */
  private async revokeGitHubTokens(accessToken: string): Promise<void> {
    try {
      const clientId = this.configs.get(AuthProvider.GITHUB)?.clientId;
      const clientSecret = this.configs.get(AuthProvider.GITHUB)?.clientSecret;

      const response = await fetch(
        `https://api.github.com/applications/${clientId}/token`,
        {
          method: 'DELETE',
          headers: {
            'Authorization': `Basic ${Buffer.from(`${clientId}:${clientSecret}`).toString('base64')}`,
            'Accept': 'application/vnd.github.v3+json',
          },
          body: JSON.stringify({ access_token: accessToken }),
        }
      );

      if (!response.ok && response.status !== 404) {
        throw new Error(`GitHub revocation failed: ${response.statusText}`);
      }
    } catch (error) {
      logger.error('Failed to revoke GitHub tokens', error);
      throw error;
    }
  }

  /**
   * Refresh OAuth tokens
   */
  async refreshOAuthTokens(userId: string, provider: AuthProvider): Promise<void> {
    try {
      const socialAccount = await prisma.socialAccount.findFirst({
        where: {
          userId,
          provider,
        },
      });

      if (!socialAccount || !socialAccount.refreshToken) {
        throw new Error('No refresh token available');
      }

      let newTokens;
      
      switch (provider) {
        case AuthProvider.GOOGLE:
          newTokens = await this.refreshGoogleTokens(socialAccount.refreshToken);
          break;
        
        case AuthProvider.LINKEDIN:
          newTokens = await this.refreshLinkedInTokens(socialAccount.refreshToken);
          break;
        
        default:
          throw new Error(`Token refresh not supported for ${provider}`);
      }

      // Update tokens
      await prisma.socialAccount.update({
        where: { id: socialAccount.id },
        data: {
          accessToken: newTokens.accessToken,
          refreshToken: newTokens.refreshToken || socialAccount.refreshToken,
          tokenExpiry: new Date(Date.now() + newTokens.expiresIn * 1000),
        },
      });

      logger.info('OAuth tokens refreshed', { userId, provider });
    } catch (error) {
      logger.error('Failed to refresh OAuth tokens', { error, userId, provider });
      throw error;
    }
  }

  /**
   * Refresh Google OAuth tokens
   */
  private async refreshGoogleTokens(refreshToken: string): Promise<any> {
    const config = this.configs.get(AuthProvider.GOOGLE)!;
    
    const response = await fetch('https://oauth2.googleapis.com/token', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
      },
      body: new URLSearchParams({
        client_id: config.clientId,
        client_secret: config.clientSecret,
        refresh_token: refreshToken,
        grant_type: 'refresh_token',
      }),
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      logger.error('Google token refresh failed', { error: errorData, status: response.status });
      throw new Error(`Google token refresh failed: ${response.statusText}`);
    }

    return response.json();
  }

  /**
   * Revoke LinkedIn OAuth tokens
   */
  private async revokeLinkedInTokens(accessToken: string): Promise<void> {
    try {
      const response = await fetch('https://api.linkedin.com/oauth/v2/revoke', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
          'Authorization': `Bearer ${accessToken}`,
        },
        body: new URLSearchParams({
          token: accessToken,
        }),
      });

      if (!response.ok && response.status !== 401) {
        throw new Error(`LinkedIn revocation failed: ${response.statusText}`);
      }
    } catch (error) {
      logger.error('Failed to revoke LinkedIn tokens', error);
      throw error;
    }
  }

  /**
   * Refresh LinkedIn OAuth tokens
   */
  private async refreshLinkedInTokens(refreshToken: string): Promise<any> {
    const config = this.configs.get(AuthProvider.LINKEDIN)!;
    
    const response = await fetch('https://api.linkedin.com/oauth/v2/accessToken', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
      },
      body: new URLSearchParams({
        grant_type: 'refresh_token',
        refresh_token: refreshToken,
        client_id: config.clientId,
        client_secret: config.clientSecret,
      }),
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      logger.error('LinkedIn token refresh failed', { error: errorData, status: response.status });
      throw new Error(`LinkedIn token refresh failed: ${response.statusText}`);
    }

    return response.json();
  }

  /**
   * Get OAuth configuration for provider
   */
  getConfig(provider: AuthProvider): OAuthConfig | undefined {
    return this.configs.get(provider);
  }

  /**
   * Check if provider is configured
   */
  isProviderConfigured(provider: AuthProvider): boolean {
    return this.configs.has(provider);
  }

  /**
   * Get configured providers
   */
  getConfiguredProviders(): AuthProvider[] {
    return Array.from(this.configs.keys());
  }

  /**
   * Check if token needs refresh (within 5 minutes of expiry)
   */
  async checkTokenExpiry(userId: string, provider: AuthProvider): Promise<boolean> {
    try {
      const socialAccount = await prisma.socialAccount.findFirst({
        where: {
          userId,
          provider,
          isLinked: true,
        },
      });

      if (!socialAccount || !socialAccount.tokenExpiry) {
        return false;
      }

      const fiveMinutesFromNow = new Date(Date.now() + 5 * 60 * 1000);
      return socialAccount.tokenExpiry <= fiveMinutesFromNow;
    } catch (error) {
      logger.error('Error checking token expiry', { error, userId, provider });
      return false;
    }
  }

  /**
   * Auto-refresh token if needed
   */
  async autoRefreshToken(userId: string, provider: AuthProvider): Promise<boolean> {
    try {
      const needsRefresh = await this.checkTokenExpiry(userId, provider);
      if (needsRefresh) {
        await this.refreshOAuthTokens(userId, provider);
        return true;
      }
      return false;
    } catch (error) {
      logger.error('Auto-refresh token failed', { error, userId, provider });
      return false;
    }
  }

  /**
   * Get valid access token (with auto-refresh and circuit breaker)
   */
  async getValidAccessToken(userId: string, provider: AuthProvider): Promise<string | null> {
    const circuitBreakerKey = `circuit_breaker:${provider}`;
    
    try {
      // Check circuit breaker status
      const breakerStatus = await this.checkCircuitBreaker(provider);
      if (breakerStatus.isOpen) {
        logger.warn(`Circuit breaker open for ${provider}`, { userId, resetTime: breakerStatus.resetTime });
        throw new Error(`Service temporarily unavailable for ${provider}`);
      }

      // Check if token needs refresh and refresh if needed
      const refreshed = await this.autoRefreshToken(userId, provider);

      const socialAccount = await prisma.socialAccount.findFirst({
        where: {
          userId,
          provider,
          isLinked: true,
        },
      });

      if (!socialAccount?.accessToken) {
        await this.recordCircuitBreakerFailure(provider);
        return null;
      }

      // Reset circuit breaker on success
      await this.resetCircuitBreaker(provider);
      return socialAccount.accessToken;
      
    } catch (error) {
      logger.error('Failed to get valid access token', { error, userId, provider });
      await this.recordCircuitBreakerFailure(provider);
      return null;
    }
  }

  /**
   * Circuit breaker implementation for OAuth providers
   */
  private async checkCircuitBreaker(provider: AuthProvider): Promise<{ isOpen: boolean; resetTime?: Date }> {
    const key = `circuit_breaker:${provider}`;
    const data = await prisma.circuitBreaker.findUnique({ where: { provider } }).catch(() => null);
    
    if (!data) return { isOpen: false };
    
    const now = new Date();
    if (data.state === 'OPEN' && data.resetTime && now < data.resetTime) {
      return { isOpen: true, resetTime: data.resetTime };
    }
    
    if (data.state === 'OPEN' && data.resetTime && now >= data.resetTime) {
      await prisma.circuitBreaker.update({
        where: { provider },
        data: { state: 'HALF_OPEN' }
      });
    }
    
    return { isOpen: false };
  }

  private async recordCircuitBreakerFailure(provider: AuthProvider): Promise<void> {
    const threshold = 5; // Open circuit after 5 failures
    const resetTimeMinutes = 15; // Reset after 15 minutes
    
    const data = await prisma.circuitBreaker.upsert({
      where: { provider },
      create: {
        provider,
        state: 'CLOSED',
        failureCount: 1,
        lastFailure: new Date()
      },
      update: {
        failureCount: { increment: 1 },
        lastFailure: new Date()
      }
    });
    
    if (data.failureCount >= threshold) {
      await prisma.circuitBreaker.update({
        where: { provider },
        data: {
          state: 'OPEN',
          resetTime: new Date(Date.now() + resetTimeMinutes * 60 * 1000)
        }
      });
      
      logger.error(`Circuit breaker opened for ${provider} due to repeated failures`, {
        failureCount: data.failureCount,
        resetTime: new Date(Date.now() + resetTimeMinutes * 60 * 1000)
      });
    }
  }

  private async resetCircuitBreaker(provider: AuthProvider): Promise<void> {
    await prisma.circuitBreaker.upsert({
      where: { provider },
      create: {
        provider,
        state: 'CLOSED',
        failureCount: 0
      },
      update: {
        state: 'CLOSED',
        failureCount: 0,
        resetTime: null
      }
    });
  }

  /**
   * Enhanced OAuth error handling with user-friendly messages and recovery suggestions
   */
  handleOAuthError(error: any, provider: AuthProvider, context?: string): {
    message: string;
    userMessage: string;
    shouldRetry: boolean;
    action?: string;
    errorCode?: string;
    recoverySteps?: string[];
  } {
    const baseMessage = `${provider} authentication failed`;
    
    if (error.message?.includes('invalid_grant') || error.message?.includes('invalid_token')) {
      return {
        message: `${baseMessage}: Token expired or invalid`,
        userMessage: `Please reconnect your ${provider} account as your authorization has expired.`,
        shouldRetry: false,
        action: 'REAUTHORIZE'
      };
    }

    if (error.message?.includes('insufficient_scope')) {
      return {
        message: `${baseMessage}: Insufficient permissions`,
        userMessage: `Please grant additional permissions to your ${provider} account for full functionality.`,
        shouldRetry: false,
        action: 'REAUTHORIZE_WITH_SCOPE'
      };
    }

    if (error.message?.includes('rate_limit') || error.status === 429) {
      return {
        message: `${baseMessage}: Rate limit exceeded`,
        userMessage: `Too many requests to ${provider}. Please try again in a few minutes.`,
        shouldRetry: true
      };
    }

    if (error.message?.includes('network') || error.code === 'ENOTFOUND') {
      return {
        message: `${baseMessage}: Network error`,
        userMessage: `Unable to connect to ${provider}. Please check your internet connection and try again.`,
        shouldRetry: true
      };
    }

    // Generic error with context-specific guidance
    const recoverySteps = this.getRecoverySteps(provider, context);
    
    return {
      message: `${baseMessage}: ${error.message}`,
      userMessage: `Something went wrong with ${provider} authentication. Please try again.`,
      shouldRetry: true,
      errorCode: 'OAUTH_GENERIC_ERROR',
      recoverySteps
    };
  }

  /**
   * Validate OAuth state parameter with timing attack protection
   */
  validateOAuthState(receivedState: string, expectedState: string): boolean {
    if (!receivedState || !expectedState) {
      logger.warn('OAuth state validation failed: Missing state parameter', {
        hasReceived: !!receivedState,
        hasExpected: !!expectedState
      });
      return false;
    }

    // Validate format first
    if (!/^[A-Za-z0-9\-_]{32,}$/.test(receivedState)) {
      logger.warn('OAuth state validation failed: Invalid format', {
        receivedLength: receivedState.length,
        receivedPreview: receivedState.substring(0, 10) + '...'
      });
      return false;
    }

    // Use constant-time comparison to prevent timing attacks
    const isValid = this.constantTimeCompare(receivedState, expectedState);
    
    if (!isValid) {
      logger.warn('OAuth state validation failed: State mismatch', {
        received: receivedState.substring(0, 10) + '...',
        expected: expectedState.substring(0, 10) + '...'
      });
      return false;
    }

    return true;
  }

  /**
   * Constant-time string comparison to prevent timing attacks
   */
  private constantTimeCompare(a: string, b: string): boolean {
    if (a.length !== b.length) {
      return false;
    }

    let result = 0;
    for (let i = 0; i < a.length; i++) {
      result |= a.charCodeAt(i) ^ b.charCodeAt(i);
    }

    return result === 0;
  }

  /**
   * Get provider-specific recovery steps
   */
  private getRecoverySteps(provider: AuthProvider, context?: string): string[] {
    const baseSteps = [
      'Check your internet connection',
      'Ensure you have a valid account with the provider',
      'Try refreshing the page and attempting again'
    ];

    const providerSteps: Record<AuthProvider, string[]> = {
      [AuthProvider.GOOGLE]: [
        ...baseSteps,
        'Verify your Google account has calendar access enabled',
        'Check if 2FA is properly configured',
        'Ensure third-party app access is allowed in Google security settings'
      ],
      [AuthProvider.GITHUB]: [
        ...baseSteps,
        'Verify your GitHub account has public profile information',
        'Check if repository access permissions are correctly set',
        'Ensure your GitHub account email is verified'
      ],
      [AuthProvider.LINKEDIN]: [
        ...baseSteps,
        'Ensure your LinkedIn profile is public',
        'Check if professional information is available',
        'Verify your LinkedIn account email is confirmed'
      ]
    };

    if (context === 'calendar_integration') {
      return [
        'Enable Google Calendar API access',
        'Grant calendar permissions in Google account settings',
        'Check calendar sharing settings',
        ...providerSteps[provider] || baseSteps
      ];
    }

    if (context === 'portfolio_sync') {
      return [
        'Ensure repository visibility settings allow access',
        'Check GitHub profile completeness',
        'Verify organization memberships are public if needed',
        ...providerSteps[provider] || baseSteps
      ];
    }

    return providerSteps[provider] || baseSteps;
  }

  /**
   * Generate cryptographically secure OAuth state with enhanced entropy
   */
  generateOAuthState(additionalEntropy?: string): string {
    const timestamp = Date.now().toString();
    const randomBytes = Buffer.from(Array.from({ length: 32 }, () => Math.floor(Math.random() * 256)));
    const entropy = additionalEntropy ? Buffer.from(additionalEntropy, 'utf8') : Buffer.alloc(0);
    
    const combined = Buffer.concat([
      Buffer.from(timestamp, 'utf8'),
      randomBytes,
      entropy
    ]);
    
    return combined
      .toString('base64')
      .replace(/[+/=]/g, (match) => {
        switch (match) {
          case '+': return '-';
          case '/': return '_';
          default: return '';
        }
      })
      .substring(0, 43); // Standard base64url length for 32 bytes
  }

  /**
   * Get enhanced profile data for LinkedIn with comprehensive information
   */
  async getLinkedInProfileData(accessToken: string): Promise<any> {
    try {
      const [basicProfile, emailProfile, positionsProfile] = await Promise.all([
        fetch('https://api.linkedin.com/v2/people/~?projection=(id,localizedFirstName,localizedLastName,profilePicture(displayImage~:playableStreams))', {
          headers: {
            'Authorization': `Bearer ${accessToken}`,
            'Accept': 'application/json',
          },
        }),
        fetch('https://api.linkedin.com/v2/emailAddresses?q=members&projection=(elements*(handle~))', {
          headers: {
            'Authorization': `Bearer ${accessToken}`,
            'Accept': 'application/json',
          },
        }),
        fetch('https://api.linkedin.com/v2/positions?q=members&projection=(elements*(id,title,companyName,summary,startDate,endDate,company(name,id)))', {
          headers: {
            'Authorization': `Bearer ${accessToken}`,
            'Accept': 'application/json',
          },
        }).catch(() => ({ json: () => Promise.resolve({ elements: [] }) })), // Graceful fallback
      ]);

      const [basic, email, positions] = await Promise.all([
        basicProfile.json(),
        emailProfile.json(),
        positionsProfile.json(),
      ]);

      // Extract profile picture URL
      const profilePictureUrl = basic?.profilePicture?.['displayImage~']?.elements?.[0]?.identifiers?.[0]?.identifier;

      return {
        id: basic?.id,
        localizedFirstName: basic?.localizedFirstName,
        localizedLastName: basic?.localizedLastName,
        emailAddress: email?.elements?.[0]?.['handle~']?.emailAddress,
        profilePicture: profilePictureUrl,
        positions: positions?.elements || [],
        professionalSummary: this.buildProfessionalSummary(positions?.elements || []),
        lastUpdated: new Date().toISOString(),
        dataQuality: this.assessLinkedInDataQuality(basic, email, positions)
      };
    } catch (error) {
      logger.error('Failed to fetch LinkedIn profile data', error);
      throw error;
    }
  }

  /**
   * Build professional summary from LinkedIn positions
   */
  private buildProfessionalSummary(positions: any[]): string {
    if (!positions || positions.length === 0) {
      return 'No professional experience available';
    }

    const currentPosition = positions.find(pos => !pos.endDate);
    if (currentPosition) {
      return `Currently ${currentPosition.title} at ${currentPosition.companyName || currentPosition.company?.name || 'Unknown Company'}`;
    }

    const mostRecentPosition = positions[0];
    return `Former ${mostRecentPosition.title} at ${mostRecentPosition.companyName || mostRecentPosition.company?.name || 'Unknown Company'}`;
  }

  /**
   * Assess LinkedIn data quality for better user experience
   */
  private assessLinkedInDataQuality(basic: any, email: any, positions: any): {
    score: number;
    completeness: string;
    missingFields: string[];
  } {
    const missingFields: string[] = [];
    let score = 0;

    if (basic?.localizedFirstName) score += 20;
    else missingFields.push('firstName');

    if (basic?.localizedLastName) score += 20;
    else missingFields.push('lastName');

    if (email?.elements?.[0]?.['handle~']?.emailAddress) score += 30;
    else missingFields.push('email');

    if (basic?.profilePicture) score += 15;
    else missingFields.push('profilePicture');

    if (positions?.elements?.length > 0) score += 15;
    else missingFields.push('experience');

    let completeness = 'poor';
    if (score >= 80) completeness = 'excellent';
    else if (score >= 60) completeness = 'good';
    else if (score >= 40) completeness = 'fair';

    return { score, completeness, missingFields };
  }
}

// Export singleton instance
export const oauthService = new OAuthService();
export default passport;