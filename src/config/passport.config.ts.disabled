/**
 * Passport Authentication Configuration
 * Handles multiple authentication strategies including JWT, Google OAuth, and GitHub OAuth
 */

import passport from 'passport';
import { Strategy as JwtStrategy, ExtractJwt, StrategyOptions as JwtOptions } from 'passport-jwt';
import { Strategy as GoogleStrategy } from 'passport-google-oauth20';
import { Strategy as GitHubStrategy } from 'passport-github2';
import { PrismaClient, AuthProvider } from '@prisma/client';
import { config } from './app.config';

const prisma = new PrismaClient();

/**
 * JWT Strategy Configuration
 * Used for API authentication with JWT tokens
 */
const jwtOptions: JwtOptions = {
  jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
  secretOrKey: config.jwt.secret,
  issuer: config.jwt.issuer,
  audience: config.jwt.audience,
};

passport.use(
  new JwtStrategy(jwtOptions, async (payload, done) => {
    try {
      // Find user by ID from JWT payload
      const user = await prisma.user.findUnique({
        where: { 
          id: payload.sub,
          isActive: true,
          isDeleted: false,
        },
        select: {
          id: true,
          email: true,
          role: true,
          isEmailVerified: true,
          twoFactorEnabled: true,
          firstName: true,
          lastName: true,
          avatar: true,
        },
      });

      if (!user) {
        return done(null, false);
      }

      // Check if account is locked
      const now = new Date();
      const userWithLock = await prisma.user.findUnique({
        where: { id: user.id },
        select: { accountLockedUntil: true },
      });

      if (userWithLock?.accountLockedUntil && userWithLock.accountLockedUntil > now) {
        return done(null, false, { message: 'Account is locked' });
      }

      return done(null, user);
    } catch (error) {
      return done(error, false);
    }
  })
);

/**
 * Google OAuth Strategy Configuration
 * Handles Google authentication and account linking
 */
passport.use(
  new GoogleStrategy(
    {
      clientID: config.oauth.google.clientId,
      clientSecret: config.oauth.google.clientSecret,
      callbackURL: config.oauth.google.callbackUrl,
      scope: ['profile', 'email'],
    },
    async (accessToken, refreshToken, profile, done) => {
      try {
        // Check if social account exists
        let socialAccount = await prisma.socialAccount.findUnique({
          where: {
            provider_providerUserId: {
              provider: AuthProvider.GOOGLE,
              providerUserId: profile.id,
            },
          },
          include: { user: true },
        });

        if (socialAccount) {
          // Update tokens and last used
          await prisma.socialAccount.update({
            where: { id: socialAccount.id },
            data: {
              accessToken,
              refreshToken: refreshToken || undefined,
              lastUsed: new Date(),
            },
          });

          // Update last login
          await prisma.user.update({
            where: { id: socialAccount.userId },
            data: { lastLoginAt: new Date() },
          });

          return done(null, socialAccount.user);
        }

        // Check if user exists with the same email
        const email = profile.emails?.[0]?.value;
        if (!email) {
          return done(new Error('No email provided by Google'), false);
        }

        let user = await prisma.user.findUnique({
          where: { email },
        });

        if (user) {
          // Link Google account to existing user
          socialAccount = await prisma.socialAccount.create({
            data: {
              userId: user.id,
              provider: AuthProvider.GOOGLE,
              providerUserId: profile.id,
              email,
              name: profile.displayName,
              avatar: profile.photos?.[0]?.value,
              accessToken,
              refreshToken,
              profile: profile._json,
            },
          });
          return done(null, { user });
        } else {
          // Create new user with Google account
          user = await prisma.user.create({
            data: {
              email,
              firstName: profile.name?.givenName,
              lastName: profile.name?.familyName,
              avatar: profile.photos?.[0]?.value,
              isEmailVerified: true, // Google emails are pre-verified
              role: 'ACTOR', // Default role, can be changed later
              socialAccounts: {
                create: {
                  provider: AuthProvider.GOOGLE,
                  providerUserId: profile.id,
                  email,
                  name: profile.displayName,
                  avatar: profile.photos?.[0]?.value,
                  accessToken,
                  refreshToken,
                  profile: profile._json,
                },
              },
            },
          });
        }

        // Update last login
        await prisma.user.update({
          where: { id: user.id },
          data: { lastLoginAt: new Date() },
        });

        return done(null, user);
      } catch (error) {
        return done(error as Error, false);
      }
    }
  )
);

/**
 * GitHub OAuth Strategy Configuration
 * Handles GitHub authentication for developer accounts
 */
passport.use(
  new GitHubStrategy(
    {
      clientID: config.oauth.github.clientId,
      clientSecret: config.oauth.github.clientSecret,
      callbackURL: config.oauth.github.callbackUrl,
      scope: ['user:email'],
    },
    async (accessToken: string, refreshToken: string, profile: any, done: any) => {
      try {
        // Check if social account exists
        let socialAccount = await prisma.socialAccount.findUnique({
          where: {
            provider_providerUserId: {
              provider: AuthProvider.GITHUB,
              providerUserId: profile.id,
            },
          },
          include: { user: true },
        });

        if (socialAccount) {
          // Update tokens and last used
          await prisma.socialAccount.update({
            where: { id: socialAccount.id },
            data: {
              accessToken,
              refreshToken: refreshToken || undefined,
              lastUsed: new Date(),
            },
          });

          // Update last login
          await prisma.user.update({
            where: { id: socialAccount.userId },
            data: { lastLoginAt: new Date() },
          });

          return done(null, socialAccount.user);
        }

        // Get primary email from GitHub
        const email = profile.emails?.[0]?.value;
        if (!email) {
          return done(new Error('No email provided by GitHub'), false);
        }

        let user = await prisma.user.findUnique({
          where: { email },
        });

        if (user) {
          // Link GitHub account to existing user
          socialAccount = await prisma.socialAccount.create({
            data: {
              userId: user.id,
              provider: AuthProvider.GITHUB,
              providerUserId: profile.id.toString(),
              email,
              name: profile.displayName || profile.username,
              avatar: profile.photos?.[0]?.value,
              accessToken,
              refreshToken,
              profile: profile._json,
            },
          });
          return done(null, { user });
        } else {
          // Create new user with GitHub account
          const nameParts = profile.displayName?.split(' ') || [];
          user = await prisma.user.create({
            data: {
              email,
              username: profile.username,
              firstName: nameParts[0] || profile.username,
              lastName: nameParts.slice(1).join(' ') || undefined,
              avatar: profile.photos?.[0]?.value,
              isEmailVerified: true, // GitHub emails are pre-verified
              role: 'ACTOR', // Default role
              bio: profile._json.bio,
              socialAccounts: {
                create: {
                  provider: AuthProvider.GITHUB,
                  providerUserId: profile.id.toString(),
                  email,
                  name: profile.displayName || profile.username,
                  avatar: profile.photos?.[0]?.value,
                  accessToken,
                  refreshToken,
                  profile: profile._json,
                },
              },
            },
          });
        }

        // Update last login
        await prisma.user.update({
          where: { id: user.id },
          data: { lastLoginAt: new Date() },
        });

        return done(null, user);
      } catch (error) {
        return done(error as Error, false);
      }
    }
  )
);

/**
 * Serialize user for session storage
 */
passport.serializeUser((user: any, done) => {
  done(null, user.id);
});

/**
 * Deserialize user from session storage
 */
passport.deserializeUser(async (id: string, done) => {
  try {
    const user = await prisma.user.findUnique({
      where: { id },
      select: {
        id: true,
        email: true,
        role: true,
        firstName: true,
        lastName: true,
        avatar: true,
        isEmailVerified: true,
        twoFactorEnabled: true,
      },
    });
    done(null, user);
  } catch (error) {
    done(error, null);
  }
});

export default passport;