name: Production Blue-Green Deployment

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      deployment_strategy:
        description: 'Deployment strategy'
        required: true
        default: 'blue-green'
        type: choice
        options:
        - blue-green
        - canary
        - rollback
      canary_percentage:
        description: 'Canary percentage (if canary strategy)'
        required: false
        default: '10'
        type: string

env:
  AWS_REGION: us-east-1
  EKS_CLUSTER_NAME: castmatch-production
  DOCKER_REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  KUBECTL_VERSION: v1.24.0

jobs:
  # Pre-deployment checks
  pre-deployment:
    name: Pre-deployment Checks
    runs-on: ubuntu-latest
    outputs:
      current_deployment: ${{ steps.check-current.outputs.current }}
      target_deployment: ${{ steps.check-current.outputs.target }}
      image_tag: ${{ steps.image-tag.outputs.tag }}
    steps:
      - uses: actions/checkout@v3

      - name: Generate image tag
        id: image-tag
        run: |
          TAG="main-$(git rev-parse --short HEAD)-$(date +%s)"
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "Generated image tag: $TAG"

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: ${{ env.KUBECTL_VERSION }}

      - name: Configure kubectl
        run: |
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}

      - name: Check current deployment
        id: check-current
        run: |
          # Check which deployment is currently active
          CURRENT=$(kubectl get service castmatch-backend-svc -n castmatch-production -o jsonpath='{.spec.selector.deployment}' || echo "blue")
          if [ "$CURRENT" = "blue" ]; then
            TARGET="green"
          else
            TARGET="blue"
          fi
          echo "current=$CURRENT" >> $GITHUB_OUTPUT
          echo "target=$TARGET" >> $GITHUB_OUTPUT
          echo "Current deployment: $CURRENT, Target deployment: $TARGET"

      - name: Run database migration check
        run: |
          # Check if database migrations are needed
          echo "Checking database migration requirements..."
          # This would typically run a migration dry-run check

      - name: Verify cluster health
        run: |
          kubectl get nodes
          kubectl get pods -n castmatch-production
          kubectl top nodes

  # Build and push images
  build-and-push:
    name: Build and Push Images
    runs-on: ubuntu-latest
    needs: pre-deployment
    permissions:
      contents: read
      packages: write
    strategy:
      matrix:
        service: [backend, frontend, python-ai]
    steps:
      - uses: actions/checkout@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ${{ env.DOCKER_REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v4
        with:
          context: ${{ matrix.service == 'python-ai' && './python-ai-service' || (matrix.service == 'frontend' && './frontend' || '.') }}
          file: ${{ matrix.service == 'backend' && './Dockerfile.backend' || (matrix.service == 'frontend' && './frontend/Dockerfile' || './python-ai-service/Dockerfile') }}
          push: true
          tags: |
            ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}-${{ matrix.service }}:${{ needs.pre-deployment.outputs.image_tag }}
            ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}-${{ matrix.service }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # Run database migrations
  database-migration:
    name: Database Migration
    runs-on: ubuntu-latest
    needs: [pre-deployment, build-and-push]
    steps:
      - uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: ${{ env.KUBECTL_VERSION }}

      - name: Configure kubectl
        run: |
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}

      - name: Run database migrations
        run: |
          kubectl create job --from=cronjob/database-migration migration-$(date +%s) -n castmatch-production
          kubectl wait --for=condition=complete --timeout=300s job/migration-$(date +%s) -n castmatch-production

  # Deploy to target environment (Green)
  deploy-target:
    name: Deploy to Target Environment
    runs-on: ubuntu-latest
    needs: [pre-deployment, build-and-push, database-migration]
    environment:
      name: production-${{ needs.pre-deployment.outputs.target_deployment }}
      url: https://api.castmatch.com
    steps:
      - uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: ${{ env.KUBECTL_VERSION }}

      - name: Configure kubectl
        run: |
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}

      - name: Update deployment image
        run: |
          TARGET="${{ needs.pre-deployment.outputs.target_deployment }}"
          IMAGE_TAG="${{ needs.pre-deployment.outputs.image_tag }}"
          
          # Update backend deployment
          kubectl set image deployment/castmatch-backend-$TARGET \
            backend=${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}-backend:$IMAGE_TAG \
            -n castmatch-production
          
          # Update AI service deployment
          kubectl set image deployment/castmatch-ai-service-$TARGET \
            ai-service=${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}-python-ai:$IMAGE_TAG \
            -n castmatch-production
          
          # Update frontend deployment
          kubectl set image deployment/castmatch-frontend-$TARGET \
            frontend=${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}-frontend:$IMAGE_TAG \
            -n castmatch-production

      - name: Scale up target deployment
        run: |
          TARGET="${{ needs.pre-deployment.outputs.target_deployment }}"
          
          # Scale up target deployments
          kubectl scale deployment castmatch-backend-$TARGET --replicas=3 -n castmatch-production
          kubectl scale deployment castmatch-ai-service-$TARGET --replicas=2 -n castmatch-production
          kubectl scale deployment castmatch-frontend-$TARGET --replicas=2 -n castmatch-production

      - name: Wait for deployment rollout
        run: |
          TARGET="${{ needs.pre-deployment.outputs.target_deployment }}"
          
          kubectl rollout status deployment/castmatch-backend-$TARGET -n castmatch-production --timeout=600s
          kubectl rollout status deployment/castmatch-ai-service-$TARGET -n castmatch-production --timeout=600s
          kubectl rollout status deployment/castmatch-frontend-$TARGET -n castmatch-production --timeout=600s

  # Health checks and smoke tests
  health-checks:
    name: Health Checks and Smoke Tests
    runs-on: ubuntu-latest
    needs: [pre-deployment, deploy-target]
    steps:
      - uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: ${{ env.KUBECTL_VERSION }}

      - name: Configure kubectl
        run: |
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}

      - name: Run health checks
        run: |
          TARGET="${{ needs.pre-deployment.outputs.target_deployment }}"
          
          # Get service endpoint for target deployment
          kubectl port-forward service/castmatch-backend-$TARGET-svc 8080:80 -n castmatch-production &
          sleep 10
          
          # Run health checks
          curl -f http://localhost:8080/health || exit 1
          curl -f http://localhost:8080/ready || exit 1
          
          # Kill port-forward
          pkill -f "kubectl port-forward"

      - name: Run smoke tests
        run: |
          # Run critical API endpoint tests
          echo "Running smoke tests against target deployment..."
          # This would typically run a subset of integration tests

      - name: Performance baseline check
        run: |
          echo "Running performance baseline checks..."
          # This would run basic load tests to ensure performance hasn't degraded

  # Traffic switching (Blue-Green or Canary)
  traffic-switch:
    name: Traffic Switching
    runs-on: ubuntu-latest
    needs: [pre-deployment, health-checks]
    steps:
      - uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: ${{ env.KUBECTL_VERSION }}

      - name: Configure kubectl
        run: |
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}

      - name: Switch traffic (Blue-Green)
        if: ${{ github.event.inputs.deployment_strategy != 'canary' }}
        run: |
          TARGET="${{ needs.pre-deployment.outputs.target_deployment }}"
          
          # Update main service selector to point to target deployment
          kubectl patch service castmatch-backend-svc -n castmatch-production \
            -p '{"spec":{"selector":{"deployment":"'$TARGET'"}}}'
          
          echo "Traffic switched to $TARGET deployment"

      - name: Gradual traffic shift (Canary)
        if: ${{ github.event.inputs.deployment_strategy == 'canary' }}
        run: |
          PERCENTAGE="${{ github.event.inputs.canary_percentage }}"
          
          # Update canary ingress with traffic percentage
          kubectl patch ingress castmatch-backend-canary-ingress -n castmatch-production \
            --type='merge' \
            -p '{"metadata":{"annotations":{"nginx.ingress.kubernetes.io/canary-weight":"'$PERCENTAGE'"}}}'
          
          echo "Canary deployment receiving $PERCENTAGE% of traffic"

  # Post-deployment verification
  post-deployment:
    name: Post-deployment Verification
    runs-on: ubuntu-latest
    needs: [pre-deployment, traffic-switch]
    steps:
      - uses: actions/checkout@v3

      - name: Monitor deployment metrics
        run: |
          echo "Monitoring deployment metrics for 5 minutes..."
          sleep 300
          
          # Check error rates, response times, etc.
          echo "Deployment verification completed"

      - name: Scale down old deployment
        run: |
          CURRENT="${{ needs.pre-deployment.outputs.current_deployment }}"
          
          # Wait before scaling down old deployment
          sleep 180
          
          kubectl scale deployment castmatch-backend-$CURRENT --replicas=0 -n castmatch-production
          kubectl scale deployment castmatch-ai-service-$CURRENT --replicas=0 -n castmatch-production
          kubectl scale deployment castmatch-frontend-$CURRENT --replicas=0 -n castmatch-production
          
          echo "Scaled down $CURRENT deployment"

      - name: Update deployment status
        run: |
          # Update deployment tracking in monitoring system
          echo "Deployment completed successfully"

      - name: Notify deployment completion
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          text: 'Production deployment completed successfully using ${{ github.event.inputs.deployment_strategy || "blue-green" }} strategy'
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}
        if: always()

  # Rollback capability
  rollback:
    name: Rollback Deployment
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.deployment_strategy == 'rollback' }}
    steps:
      - uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: ${{ env.KUBECTL_VERSION }}

      - name: Configure kubectl
        run: |
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}

      - name: Execute rollback
        run: |
          # Rollback to previous deployment
          kubectl rollout undo deployment/castmatch-backend-blue -n castmatch-production
          kubectl rollout undo deployment/castmatch-backend-green -n castmatch-production
          
          echo "Rollback completed"